!function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}__webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{enumerable:!0,get:getter})},__webpack_require__.r=function(exports){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})},__webpack_require__.t=function(value,mode){if(1&mode&&(value=__webpack_require__(value)),8&mode)return value;if(4&mode&&"object"==typeof value&&value&&value.__esModule)return value;var ns=Object.create(null);if(__webpack_require__.r(ns),Object.defineProperty(ns,"default",{enumerable:!0,value:value}),2&mode&&"string"!=typeof value)for(var key in value)__webpack_require__.d(ns,key,function(key){return value[key]}.bind(null,key));return ns},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function getDefault(){return module.default}:function getModuleExports(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=5)}([function(module,exports,__webpack_require__){"use strict";try{self["workbox:core:6.1.5"]&&_()}catch(e){}},function(module,exports,__webpack_require__){"use strict";try{self["workbox:precaching:6.1.5"]&&_()}catch(e){}},function(module,exports,__webpack_require__){"use strict";try{self["workbox:routing:6.1.5"]&&_()}catch(e){}},function(module,exports,__webpack_require__){"use strict";try{self["workbox:strategies:6.1.5"]&&_()}catch(e){}},function(module,exports,__webpack_require__){"use strict";try{self["workbox:expiration:6.1.5"]&&_()}catch(e){}},function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);__webpack_require__(0);const messageGenerator=(code,...args)=>{let msg=code;return args.length>0&&(msg+=` :: ${JSON.stringify(args)}`),msg};class WorkboxError_WorkboxError extends Error{constructor(errorCode,details){super(messageGenerator(errorCode,details)),this.name=errorCode,this.details=details}}const quotaErrorCallbacks=new Set;const _cacheNameDetails={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:"undefined"!=typeof registration?registration.scope:""},_createCacheName=cacheName=>[_cacheNameDetails.prefix,cacheName,_cacheNameDetails.suffix].filter((value=>value&&value.length>0)).join("-"),cacheNames_getPrecacheName=userCacheName=>userCacheName||_createCacheName(_cacheNameDetails.precache),cacheNames_getRuntimeName=userCacheName=>userCacheName||_createCacheName(_cacheNameDetails.runtime);function stripParams(fullURL,ignoreParams){const strippedURL=new URL(fullURL);for(const param of ignoreParams)strippedURL.searchParams.delete(param);return strippedURL.href}let canConstructResponseFromBodyStream_supportStatus;function dontWaitFor(promise){promise.then((()=>{}))}class DBWrapper{constructor(name,version,{onupgradeneeded:onupgradeneeded,onversionchange:onversionchange}={}){this._db=null,this._name=name,this._version=version,this._onupgradeneeded=onupgradeneeded,this._onversionchange=onversionchange||(()=>this.close())}get db(){return this._db}async open(){if(!this._db)return this._db=await new Promise(((resolve,reject)=>{let openRequestTimedOut=!1;setTimeout((()=>{openRequestTimedOut=!0,reject(new Error("The open request was blocked and timed out"))}),this.OPEN_TIMEOUT);const openRequest=indexedDB.open(this._name,this._version);openRequest.onerror=()=>reject(openRequest.error),openRequest.onupgradeneeded=evt=>{openRequestTimedOut?(openRequest.transaction.abort(),openRequest.result.close()):"function"==typeof this._onupgradeneeded&&this._onupgradeneeded(evt)},openRequest.onsuccess=()=>{const db=openRequest.result;openRequestTimedOut?db.close():(db.onversionchange=this._onversionchange.bind(this),resolve(db))}})),this}async getKey(storeName,query){return(await this.getAllKeys(storeName,query,1))[0]}async getAll(storeName,query,count){return await this.getAllMatching(storeName,{query:query,count:count})}async getAllKeys(storeName,query,count){return(await this.getAllMatching(storeName,{query:query,count:count,includeKeys:!0})).map((entry=>entry.key))}async getAllMatching(storeName,{index:index,query:query=null,direction:direction="next",count:count,includeKeys:includeKeys=!1}={}){return await this.transaction([storeName],"readonly",((txn,done)=>{const store=txn.objectStore(storeName),target=index?store.index(index):store,results=[],request=target.openCursor(query,direction);request.onsuccess=()=>{const cursor=request.result;cursor?(results.push(includeKeys?cursor:cursor.value),count&&results.length>=count?done(results):cursor.continue()):done(results)}}))}async transaction(storeNames,type,callback){return await this.open(),await new Promise(((resolve,reject)=>{const txn=this._db.transaction(storeNames,type);txn.onabort=()=>reject(txn.error),txn.oncomplete=()=>resolve(),callback(txn,(value=>resolve(value)))}))}async _call(method,storeName,type,...args){return await this.transaction([storeName],type,((txn,done)=>{const objStore=txn.objectStore(storeName),request=objStore[method].apply(objStore,args);request.onsuccess=()=>done(request.result)}))}close(){this._db&&(this._db.close(),this._db=null)}}DBWrapper.prototype.OPEN_TIMEOUT=2e3;const methodsToWrap={readonly:["get","count","getKey","getAll","getAllKeys"],readwrite:["add","put","clear","delete"]};for(const[mode,methods]of Object.entries(methodsToWrap))for(const method of methods)method in IDBObjectStore.prototype&&(DBWrapper.prototype[method]=async function(storeName,...args){return await this._call(method,storeName,mode,...args)});class Deferred{constructor(){this.promise=new Promise(((resolve,reject)=>{this.resolve=resolve,this.reject=reject}))}}const getFriendlyURL=url=>new URL(String(url),location.href).href.replace(new RegExp(`^${location.origin}`),"");function timeout(ms){return new Promise((resolve=>setTimeout(resolve,ms)))}function waitUntil(event,asyncFn){const returnPromise=asyncFn();return event.waitUntil(returnPromise),returnPromise}async function copyResponse(response,modifier){let origin=null;if(response.url){origin=new URL(response.url).origin}if(origin!==self.location.origin)throw new WorkboxError_WorkboxError("cross-origin-copy-response",{origin:origin});const clonedResponse=response.clone(),responseInit={headers:new Headers(clonedResponse.headers),status:clonedResponse.status,statusText:clonedResponse.statusText},modifiedResponseInit=modifier?modifier(responseInit):responseInit,body=function canConstructResponseFromBodyStream(){if(void 0===canConstructResponseFromBodyStream_supportStatus){const testResponse=new Response("");if("body"in testResponse)try{new Response(testResponse.body),canConstructResponseFromBodyStream_supportStatus=!0}catch(error){canConstructResponseFromBodyStream_supportStatus=!1}canConstructResponseFromBodyStream_supportStatus=!1}return canConstructResponseFromBodyStream_supportStatus}()?clonedResponse.body:await clonedResponse.blob();return new Response(body,modifiedResponseInit)}__webpack_require__(4);const normalizeURL=unNormalizedUrl=>{const url=new URL(unNormalizedUrl,location.href);return url.hash="",url.href};class CacheTimestampsModel_CacheTimestampsModel{constructor(cacheName){this._cacheName=cacheName,this._db=new DBWrapper("workbox-expiration",1,{onupgradeneeded:event=>this._handleUpgrade(event)})}_handleUpgrade(event){const objStore=event.target.result.createObjectStore("cache-entries",{keyPath:"id"});objStore.createIndex("cacheName","cacheName",{unique:!1}),objStore.createIndex("timestamp","timestamp",{unique:!1}),(async name=>{await new Promise(((resolve,reject)=>{const request=indexedDB.deleteDatabase(name);request.onerror=()=>{reject(request.error)},request.onblocked=()=>{reject(new Error("Delete blocked"))},request.onsuccess=()=>{resolve()}}))})(this._cacheName)}async setTimestamp(url,timestamp){const entry={url:url=normalizeURL(url),timestamp:timestamp,cacheName:this._cacheName,id:this._getId(url)};await this._db.put("cache-entries",entry)}async getTimestamp(url){return(await this._db.get("cache-entries",this._getId(url))).timestamp}async expireEntries(minTimestamp,maxCount){const entriesToDelete=await this._db.transaction("cache-entries","readwrite",((txn,done)=>{const request=txn.objectStore("cache-entries").index("timestamp").openCursor(null,"prev"),entriesToDelete=[];let entriesNotDeletedCount=0;request.onsuccess=()=>{const cursor=request.result;if(cursor){const result=cursor.value;result.cacheName===this._cacheName&&(minTimestamp&&result.timestamp<minTimestamp||maxCount&&entriesNotDeletedCount>=maxCount?entriesToDelete.push(cursor.value):entriesNotDeletedCount++),cursor.continue()}else done(entriesToDelete)}})),urlsDeleted=[];for(const entry of entriesToDelete)await this._db.delete("cache-entries",entry.id),urlsDeleted.push(entry.url);return urlsDeleted}_getId(url){return this._cacheName+"|"+normalizeURL(url)}}class CacheExpiration_CacheExpiration{constructor(cacheName,config={}){this._isRunning=!1,this._rerunRequested=!1,this._maxEntries=config.maxEntries,this._maxAgeSeconds=config.maxAgeSeconds,this._matchOptions=config.matchOptions,this._cacheName=cacheName,this._timestampModel=new CacheTimestampsModel_CacheTimestampsModel(cacheName)}async expireEntries(){if(this._isRunning)return void(this._rerunRequested=!0);this._isRunning=!0;const minTimestamp=this._maxAgeSeconds?Date.now()-1e3*this._maxAgeSeconds:0,urlsExpired=await this._timestampModel.expireEntries(minTimestamp,this._maxEntries),cache=await self.caches.open(this._cacheName);for(const url of urlsExpired)await cache.delete(url,this._matchOptions);this._isRunning=!1,this._rerunRequested&&(this._rerunRequested=!1,dontWaitFor(this.expireEntries()))}async updateTimestamp(url){await this._timestampModel.setTimestamp(url,Date.now())}async isURLExpired(url){if(this._maxAgeSeconds){return await this._timestampModel.getTimestamp(url)<Date.now()-1e3*this._maxAgeSeconds}return!1}async delete(){this._rerunRequested=!1,await this._timestampModel.expireEntries(1/0)}}__webpack_require__(1);function createCacheKey(entry){if(!entry)throw new WorkboxError_WorkboxError("add-to-cache-list-unexpected-type",{entry:entry});if("string"==typeof entry){const urlObject=new URL(entry,location.href);return{cacheKey:urlObject.href,url:urlObject.href}}const{revision:revision,url:url}=entry;if(!url)throw new WorkboxError_WorkboxError("add-to-cache-list-unexpected-type",{entry:entry});if(!revision){const urlObject=new URL(url,location.href);return{cacheKey:urlObject.href,url:urlObject.href}}const cacheKeyURL=new URL(url,location.href),originalURL=new URL(url,location.href);return cacheKeyURL.searchParams.set("__WB_REVISION__",revision),{cacheKey:cacheKeyURL.href,url:originalURL.href}}class PrecacheInstallReportPlugin{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async({request:request,state:state})=>{state&&(state.originalRequest=request)},this.cachedResponseWillBeUsed=async({event:event,state:state,cachedResponse:cachedResponse})=>{if("install"===event.type){const url=state.originalRequest.url;cachedResponse?this.notUpdatedURLs.push(url):this.updatedURLs.push(url)}return cachedResponse}}}class PrecacheCacheKeyPlugin{constructor({precacheController:precacheController}){this.cacheKeyWillBeUsed=async({request:request,params:params})=>{const cacheKey=params&&params.cacheKey||this._precacheController.getCacheKeyForURL(request.url);return cacheKey?new Request(cacheKey):request},this._precacheController=precacheController}}__webpack_require__(3);function toRequest(input){return"string"==typeof input?new Request(input):input}class StrategyHandler_StrategyHandler{constructor(strategy,options){this._cacheKeys={},Object.assign(this,options),this.event=options.event,this._strategy=strategy,this._handlerDeferred=new Deferred,this._extendLifetimePromises=[],this._plugins=[...strategy.plugins],this._pluginStateMap=new Map;for(const plugin of this._plugins)this._pluginStateMap.set(plugin,{});this.event.waitUntil(this._handlerDeferred.promise)}async fetch(input){const{event:event}=this;let request=toRequest(input);if("navigate"===request.mode&&event instanceof FetchEvent&&event.preloadResponse){const possiblePreloadResponse=await event.preloadResponse;if(possiblePreloadResponse)return possiblePreloadResponse}const originalRequest=this.hasCallback("fetchDidFail")?request.clone():null;try{for(const cb of this.iterateCallbacks("requestWillFetch"))request=await cb({request:request.clone(),event:event})}catch(err){throw new WorkboxError_WorkboxError("plugin-error-request-will-fetch",{thrownError:err})}const pluginFilteredRequest=request.clone();try{let fetchResponse;fetchResponse=await fetch(request,"navigate"===request.mode?void 0:this._strategy.fetchOptions);for(const callback of this.iterateCallbacks("fetchDidSucceed"))fetchResponse=await callback({event:event,request:pluginFilteredRequest,response:fetchResponse});return fetchResponse}catch(error){throw originalRequest&&await this.runCallbacks("fetchDidFail",{error:error,event:event,originalRequest:originalRequest.clone(),request:pluginFilteredRequest.clone()}),error}}async fetchAndCachePut(input){const response=await this.fetch(input),responseClone=response.clone();return this.waitUntil(this.cachePut(input,responseClone)),response}async cacheMatch(key){const request=toRequest(key);let cachedResponse;const{cacheName:cacheName,matchOptions:matchOptions}=this._strategy,effectiveRequest=await this.getCacheKey(request,"read"),multiMatchOptions={...matchOptions,cacheName:cacheName};cachedResponse=await caches.match(effectiveRequest,multiMatchOptions);for(const callback of this.iterateCallbacks("cachedResponseWillBeUsed"))cachedResponse=await callback({cacheName:cacheName,matchOptions:matchOptions,cachedResponse:cachedResponse,request:effectiveRequest,event:this.event})||void 0;return cachedResponse}async cachePut(key,response){const request=toRequest(key);await timeout(0);const effectiveRequest=await this.getCacheKey(request,"write");if(!response)throw new WorkboxError_WorkboxError("cache-put-with-no-response",{url:getFriendlyURL(effectiveRequest.url)});const responseToCache=await this._ensureResponseSafeToCache(response);if(!responseToCache)return!1;const{cacheName:cacheName,matchOptions:matchOptions}=this._strategy,cache=await self.caches.open(cacheName),hasCacheUpdateCallback=this.hasCallback("cacheDidUpdate"),oldResponse=hasCacheUpdateCallback?await async function cacheMatchIgnoreParams(cache,request,ignoreParams,matchOptions){const strippedRequestURL=stripParams(request.url,ignoreParams);if(request.url===strippedRequestURL)return cache.match(request,matchOptions);const keysOptions={...matchOptions,ignoreSearch:!0},cacheKeys=await cache.keys(request,keysOptions);for(const cacheKey of cacheKeys)if(strippedRequestURL===stripParams(cacheKey.url,ignoreParams))return cache.match(cacheKey,matchOptions)}(cache,effectiveRequest.clone(),["__WB_REVISION__"],matchOptions):null;try{await cache.put(effectiveRequest,hasCacheUpdateCallback?responseToCache.clone():responseToCache)}catch(error){throw"QuotaExceededError"===error.name&&await async function executeQuotaErrorCallbacks(){for(const callback of quotaErrorCallbacks)await callback()}(),error}for(const callback of this.iterateCallbacks("cacheDidUpdate"))await callback({cacheName:cacheName,oldResponse:oldResponse,newResponse:responseToCache.clone(),request:effectiveRequest,event:this.event});return!0}async getCacheKey(request,mode){if(!this._cacheKeys[mode]){let effectiveRequest=request;for(const callback of this.iterateCallbacks("cacheKeyWillBeUsed"))effectiveRequest=toRequest(await callback({mode:mode,request:effectiveRequest,event:this.event,params:this.params}));this._cacheKeys[mode]=effectiveRequest}return this._cacheKeys[mode]}hasCallback(name){for(const plugin of this._strategy.plugins)if(name in plugin)return!0;return!1}async runCallbacks(name,param){for(const callback of this.iterateCallbacks(name))await callback(param)}*iterateCallbacks(name){for(const plugin of this._strategy.plugins)if("function"==typeof plugin[name]){const state=this._pluginStateMap.get(plugin),statefulCallback=param=>{const statefulParam={...param,state:state};return plugin[name](statefulParam)};yield statefulCallback}}waitUntil(promise){return this._extendLifetimePromises.push(promise),promise}async doneWaiting(){let promise;for(;promise=this._extendLifetimePromises.shift();)await promise}destroy(){this._handlerDeferred.resolve()}async _ensureResponseSafeToCache(response){let responseToCache=response,pluginsUsed=!1;for(const callback of this.iterateCallbacks("cacheWillUpdate"))if(responseToCache=await callback({request:this.request,response:responseToCache,event:this.event})||void 0,pluginsUsed=!0,!responseToCache)break;return pluginsUsed||responseToCache&&200!==responseToCache.status&&(responseToCache=void 0),responseToCache}}class Strategy_Strategy{constructor(options={}){this.cacheName=cacheNames_getRuntimeName(options.cacheName),this.plugins=options.plugins||[],this.fetchOptions=options.fetchOptions,this.matchOptions=options.matchOptions}handle(options){const[responseDone]=this.handleAll(options);return responseDone}handleAll(options){options instanceof FetchEvent&&(options={event:options,request:options.request});const event=options.event,request="string"==typeof options.request?new Request(options.request):options.request,params="params"in options?options.params:void 0,handler=new StrategyHandler_StrategyHandler(this,{event:event,request:request,params:params}),responseDone=this._getResponse(handler,request,event);return[responseDone,this._awaitComplete(responseDone,handler,request,event)]}async _getResponse(handler,request,event){let response;await handler.runCallbacks("handlerWillStart",{event:event,request:request});try{if(response=await this._handle(request,handler),!response||"error"===response.type)throw new WorkboxError_WorkboxError("no-response",{url:request.url})}catch(error){for(const callback of handler.iterateCallbacks("handlerDidError"))if(response=await callback({error:error,event:event,request:request}),response)break;if(!response)throw error}for(const callback of handler.iterateCallbacks("handlerWillRespond"))response=await callback({event:event,request:request,response:response});return response}async _awaitComplete(responseDone,handler,request,event){let response,error;try{response=await responseDone}catch(error){}try{await handler.runCallbacks("handlerDidRespond",{event:event,request:request,response:response}),await handler.doneWaiting()}catch(waitUntilError){error=waitUntilError}if(await handler.runCallbacks("handlerDidComplete",{event:event,request:request,response:response,error:error}),handler.destroy(),error)throw error}}class PrecacheStrategy_PrecacheStrategy extends Strategy_Strategy{constructor(options={}){options.cacheName=cacheNames_getPrecacheName(options.cacheName),super(options),this._fallbackToNetwork=!1!==options.fallbackToNetwork,this.plugins.push(PrecacheStrategy_PrecacheStrategy.copyRedirectedCacheableResponsesPlugin)}async _handle(request,handler){const response=await handler.cacheMatch(request);return response||(handler.event&&"install"===handler.event.type?await this._handleInstall(request,handler):await this._handleFetch(request,handler))}async _handleFetch(request,handler){let response;if(!this._fallbackToNetwork)throw new WorkboxError_WorkboxError("missing-precache-entry",{cacheName:this.cacheName,url:request.url});return response=await handler.fetch(request),response}async _handleInstall(request,handler){this._useDefaultCacheabilityPluginIfNeeded();const response=await handler.fetch(request);if(!await handler.cachePut(request,response.clone()))throw new WorkboxError_WorkboxError("bad-precaching-response",{url:request.url,status:response.status});return response}_useDefaultCacheabilityPluginIfNeeded(){let defaultPluginIndex=null,cacheWillUpdatePluginCount=0;for(const[index,plugin]of this.plugins.entries())plugin!==PrecacheStrategy_PrecacheStrategy.copyRedirectedCacheableResponsesPlugin&&(plugin===PrecacheStrategy_PrecacheStrategy.defaultPrecacheCacheabilityPlugin&&(defaultPluginIndex=index),plugin.cacheWillUpdate&&cacheWillUpdatePluginCount++);0===cacheWillUpdatePluginCount?this.plugins.push(PrecacheStrategy_PrecacheStrategy.defaultPrecacheCacheabilityPlugin):cacheWillUpdatePluginCount>1&&null!==defaultPluginIndex&&this.plugins.splice(defaultPluginIndex,1)}}PrecacheStrategy_PrecacheStrategy.defaultPrecacheCacheabilityPlugin={cacheWillUpdate:async({response:response})=>!response||response.status>=400?null:response},PrecacheStrategy_PrecacheStrategy.copyRedirectedCacheableResponsesPlugin={cacheWillUpdate:async({response:response})=>response.redirected?await copyResponse(response):response};class PrecacheController_PrecacheController{constructor({cacheName:cacheName,plugins:plugins=[],fallbackToNetwork:fallbackToNetwork=!0}={}){this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map,this._strategy=new PrecacheStrategy_PrecacheStrategy({cacheName:cacheNames_getPrecacheName(cacheName),plugins:[...plugins,new PrecacheCacheKeyPlugin({precacheController:this})],fallbackToNetwork:fallbackToNetwork}),this.install=this.install.bind(this),this.activate=this.activate.bind(this)}get strategy(){return this._strategy}precache(entries){this.addToCacheList(entries),this._installAndActiveListenersAdded||(self.addEventListener("install",this.install),self.addEventListener("activate",this.activate),this._installAndActiveListenersAdded=!0)}addToCacheList(entries){const urlsToWarnAbout=[];for(const entry of entries){"string"==typeof entry?urlsToWarnAbout.push(entry):entry&&void 0===entry.revision&&urlsToWarnAbout.push(entry.url);const{cacheKey:cacheKey,url:url}=createCacheKey(entry),cacheMode="string"!=typeof entry&&entry.revision?"reload":"default";if(this._urlsToCacheKeys.has(url)&&this._urlsToCacheKeys.get(url)!==cacheKey)throw new WorkboxError_WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(url),secondEntry:cacheKey});if("string"!=typeof entry&&entry.integrity){if(this._cacheKeysToIntegrities.has(cacheKey)&&this._cacheKeysToIntegrities.get(cacheKey)!==entry.integrity)throw new WorkboxError_WorkboxError("add-to-cache-list-conflicting-integrities",{url:url});this._cacheKeysToIntegrities.set(cacheKey,entry.integrity)}if(this._urlsToCacheKeys.set(url,cacheKey),this._urlsToCacheModes.set(url,cacheMode),urlsToWarnAbout.length>0){const warningMessage=`Workbox is precaching URLs without revision info: ${urlsToWarnAbout.join(", ")}\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;console.warn(warningMessage)}}}install(event){return waitUntil(event,(async()=>{const installReportPlugin=new PrecacheInstallReportPlugin;this.strategy.plugins.push(installReportPlugin);for(const[url,cacheKey]of this._urlsToCacheKeys){const integrity=this._cacheKeysToIntegrities.get(cacheKey),cacheMode=this._urlsToCacheModes.get(url),request=new Request(url,{integrity:integrity,cache:cacheMode,credentials:"same-origin"});await Promise.all(this.strategy.handleAll({params:{cacheKey:cacheKey},request:request,event:event}))}const{updatedURLs:updatedURLs,notUpdatedURLs:notUpdatedURLs}=installReportPlugin;return{updatedURLs:updatedURLs,notUpdatedURLs:notUpdatedURLs}}))}activate(event){return waitUntil(event,(async()=>{const cache=await self.caches.open(this.strategy.cacheName),currentlyCachedRequests=await cache.keys(),expectedCacheKeys=new Set(this._urlsToCacheKeys.values()),deletedURLs=[];for(const request of currentlyCachedRequests)expectedCacheKeys.has(request.url)||(await cache.delete(request),deletedURLs.push(request.url));return{deletedURLs:deletedURLs}}))}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(url){const urlObject=new URL(url,location.href);return this._urlsToCacheKeys.get(urlObject.href)}async matchPrecache(request){const url=request instanceof Request?request.url:request,cacheKey=this.getCacheKeyForURL(url);if(cacheKey){return(await self.caches.open(this.strategy.cacheName)).match(cacheKey)}}createHandlerBoundToURL(url){const cacheKey=this.getCacheKeyForURL(url);if(!cacheKey)throw new WorkboxError_WorkboxError("non-precached-url",{url:url});return options=>(options.request=new Request(url),options.params={cacheKey:cacheKey,...options.params},this.strategy.handle(options))}}let getOrCreatePrecacheController_precacheController;const getOrCreatePrecacheController=()=>(getOrCreatePrecacheController_precacheController||(getOrCreatePrecacheController_precacheController=new PrecacheController_PrecacheController),getOrCreatePrecacheController_precacheController);__webpack_require__(2);const normalizeHandler=handler=>handler&&"object"==typeof handler?handler:{handle:handler};class Route_Route{constructor(match,handler,method="GET"){this.handler=normalizeHandler(handler),this.match=match,this.method=method}setCatchHandler(handler){this.catchHandler=normalizeHandler(handler)}}class RegExpRoute_RegExpRoute extends Route_Route{constructor(regExp,handler,method){super((({url:url})=>{const result=regExp.exec(url.href);if(result&&(url.origin===location.origin||0===result.index))return result.slice(1)}),handler,method)}}class Router_Router{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",(event=>{const{request:request}=event,responsePromise=this.handleRequest({request:request,event:event});responsePromise&&event.respondWith(responsePromise)}))}addCacheListener(){self.addEventListener("message",(event=>{if(event.data&&"CACHE_URLS"===event.data.type){const{payload:payload}=event.data;0;const requestPromises=Promise.all(payload.urlsToCache.map((entry=>{"string"==typeof entry&&(entry=[entry]);const request=new Request(...entry);return this.handleRequest({request:request,event:event})})));event.waitUntil(requestPromises),event.ports&&event.ports[0]&&requestPromises.then((()=>event.ports[0].postMessage(!0)))}}))}handleRequest({request:request,event:event}){const url=new URL(request.url,location.href);if(!url.protocol.startsWith("http"))return void 0;const sameOrigin=url.origin===location.origin,{params:params,route:route}=this.findMatchingRoute({event:event,request:request,sameOrigin:sameOrigin,url:url});let handler=route&&route.handler;const method=request.method;if(!handler&&this._defaultHandlerMap.has(method)&&(handler=this._defaultHandlerMap.get(method)),!handler)return void 0;let responsePromise;try{responsePromise=handler.handle({url:url,request:request,event:event,params:params})}catch(err){responsePromise=Promise.reject(err)}const catchHandler=route&&route.catchHandler;return responsePromise instanceof Promise&&(this._catchHandler||catchHandler)&&(responsePromise=responsePromise.catch((async err=>{if(catchHandler){0;try{return await catchHandler.handle({url:url,request:request,event:event,params:params})}catch(catchErr){err=catchErr}}if(this._catchHandler)return this._catchHandler.handle({url:url,request:request,event:event});throw err}))),responsePromise}findMatchingRoute({url:url,sameOrigin:sameOrigin,request:request,event:event}){const routes=this._routes.get(request.method)||[];for(const route of routes){let params;const matchResult=route.match({url:url,sameOrigin:sameOrigin,request:request,event:event});if(matchResult)return params=matchResult,(Array.isArray(matchResult)&&0===matchResult.length||matchResult.constructor===Object&&0===Object.keys(matchResult).length||"boolean"==typeof matchResult)&&(params=void 0),{route:route,params:params}}return{}}setDefaultHandler(handler,method="GET"){this._defaultHandlerMap.set(method,normalizeHandler(handler))}setCatchHandler(handler){this._catchHandler=normalizeHandler(handler)}registerRoute(route){this._routes.has(route.method)||this._routes.set(route.method,[]),this._routes.get(route.method).push(route)}unregisterRoute(route){if(!this._routes.has(route.method))throw new WorkboxError_WorkboxError("unregister-route-but-not-found-with-method",{method:route.method});const routeIndex=this._routes.get(route.method).indexOf(route);if(!(routeIndex>-1))throw new WorkboxError_WorkboxError("unregister-route-route-not-registered");this._routes.get(route.method).splice(routeIndex,1)}}let getOrCreateDefaultRouter_defaultRouter;const getOrCreateDefaultRouter=()=>(getOrCreateDefaultRouter_defaultRouter||(getOrCreateDefaultRouter_defaultRouter=new Router_Router,getOrCreateDefaultRouter_defaultRouter.addFetchListener(),getOrCreateDefaultRouter_defaultRouter.addCacheListener()),getOrCreateDefaultRouter_defaultRouter);function registerRoute(capture,handler,method){let route;if("string"==typeof capture){const captureUrl=new URL(capture,location.href);0;route=new Route_Route((({url:url})=>url.href===captureUrl.href),handler,method)}else if(capture instanceof RegExp)route=new RegExpRoute_RegExpRoute(capture,handler,method);else if("function"==typeof capture)route=new Route_Route(capture,handler,method);else{if(!(capture instanceof Route_Route))throw new WorkboxError_WorkboxError("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});route=capture}return getOrCreateDefaultRouter().registerRoute(route),route}class PrecacheRoute_PrecacheRoute extends Route_Route{constructor(precacheController,options){super((({request:request})=>{const urlsToCacheKeys=precacheController.getURLsToCacheKeys();for(const possibleURL of function*generateURLVariations(url,{ignoreURLParametersMatching:ignoreURLParametersMatching=[/^utm_/,/^fbclid$/],directoryIndex:directoryIndex="index.html",cleanURLs:cleanURLs=!0,urlManipulation:urlManipulation}={}){const urlObject=new URL(url,location.href);urlObject.hash="",yield urlObject.href;const urlWithoutIgnoredParams=function removeIgnoredSearchParams(urlObject,ignoreURLParametersMatching=[]){for(const paramName of[...urlObject.searchParams.keys()])ignoreURLParametersMatching.some((regExp=>regExp.test(paramName)))&&urlObject.searchParams.delete(paramName);return urlObject}(urlObject,ignoreURLParametersMatching);if(yield urlWithoutIgnoredParams.href,directoryIndex&&urlWithoutIgnoredParams.pathname.endsWith("/")){const directoryURL=new URL(urlWithoutIgnoredParams.href);directoryURL.pathname+=directoryIndex,yield directoryURL.href}if(cleanURLs){const cleanURL=new URL(urlWithoutIgnoredParams.href);cleanURL.pathname+=".html",yield cleanURL.href}if(urlManipulation){const additionalURLs=urlManipulation({url:urlObject});for(const urlToAttempt of additionalURLs)yield urlToAttempt.href}}(request.url,options)){const cacheKey=urlsToCacheKeys.get(possibleURL);if(cacheKey)return{cacheKey:cacheKey}}}),precacheController.strategy)}}const cacheOkAndOpaquePlugin={cacheWillUpdate:async({response:response})=>200===response.status||0===response.status?response:null};!function clientsClaim(){self.addEventListener("activate",(()=>self.clients.claim()))}(),function precacheAndRoute(entries,options){!function precache(entries){getOrCreatePrecacheController().precache(entries)}(entries),function addRoute(options){const precacheController=getOrCreatePrecacheController();registerRoute(new PrecacheRoute_PrecacheRoute(precacheController,options))}(options)}([{'revision':null,'url':'0.526443b6.iframe.bundle.js'},{'revision':null,'url':'1.248995ef.iframe.bundle.js'},{'revision':null,'url':'10.c107dfc7.iframe.bundle.js'},{'revision':null,'url':'11.397203ea.iframe.bundle.js'},{'revision':null,'url':'12.19b4f7dd.iframe.bundle.js'},{'revision':null,'url':'13.ba164429.iframe.bundle.js'},{'revision':null,'url':'14.2549623b.iframe.bundle.js'},{'revision':null,'url':'15.7259e293.iframe.bundle.js'},{'revision':null,'url':'16.6d17cc1b.iframe.bundle.js'},{'revision':null,'url':'17.a3c8198a.iframe.bundle.js'},{'revision':null,'url':'18.e67da2a5.iframe.bundle.js'},{'revision':null,'url':'19.67dad75b.iframe.bundle.js'},{'revision':null,'url':'20.33967ada.iframe.bundle.js'},{'revision':null,'url':'21.fc166110.iframe.bundle.js'},{'revision':null,'url':'22.020a0c67.iframe.bundle.js'},{'revision':null,'url':'23.ec336e5e.iframe.bundle.js'},{'revision':null,'url':'24.0ce304c9.iframe.bundle.js'},{'revision':null,'url':'25.056fb3eb.iframe.bundle.js'},{'revision':null,'url':'26.0b5545b2.iframe.bundle.js'},{'revision':null,'url':'27.6081ac62.iframe.bundle.js'},{'revision':null,'url':'28.6eabe34f.iframe.bundle.js'},{'revision':null,'url':'29.bebfa2a0.iframe.bundle.js'},{'revision':null,'url':'30.3a84f361.iframe.bundle.js'},{'revision':null,'url':'31.a91c92eb.iframe.bundle.js'},{'revision':null,'url':'32.d1f11bb9.iframe.bundle.js'},{'revision':null,'url':'33.286b2aff.iframe.bundle.js'},{'revision':null,'url':'34.edcd082a.iframe.bundle.js'},{'revision':null,'url':'35.08f70814.iframe.bundle.js'},{'revision':null,'url':'36.30e09a66.iframe.bundle.js'},{'revision':null,'url':'37.2b1935a4.iframe.bundle.js'},{'revision':null,'url':'38.642608ec.iframe.bundle.js'},{'revision':null,'url':'39.4a668115.iframe.bundle.js'},{'revision':null,'url':'40.a9d2699f.iframe.bundle.js'},{'revision':null,'url':'41.3ae2c29c.iframe.bundle.js'},{'revision':null,'url':'42.70c223b8.iframe.bundle.js'},{'revision':null,'url':'43.e85c0238.iframe.bundle.js'},{'revision':null,'url':'44.3417c138.iframe.bundle.js'},{'revision':null,'url':'45.6bcac6f7.iframe.bundle.js'},{'revision':null,'url':'46.d154b570.iframe.bundle.js'},{'revision':null,'url':'47.85c8188c.iframe.bundle.js'},{'revision':null,'url':'48.b9b9d69c.iframe.bundle.js'},{'revision':null,'url':'49.68ee6b4a.iframe.bundle.js'},{'revision':null,'url':'50.685306a6.iframe.bundle.js'},{'revision':null,'url':'51.40dd9e78.iframe.bundle.js'},{'revision':null,'url':'52.68c3825e.iframe.bundle.js'},{'revision':null,'url':'53.a0627476.iframe.bundle.js'},{'revision':null,'url':'54.0687632c.iframe.bundle.js'},{'revision':null,'url':'55.3525207d.iframe.bundle.js'},{'revision':null,'url':'56.761009c3.iframe.bundle.js'},{'revision':null,'url':'57.24bcdcaf.iframe.bundle.js'},{'revision':null,'url':'58.b623cfd0.iframe.bundle.js'},{'revision':null,'url':'59.c991efeb.iframe.bundle.js'},{'revision':null,'url':'60.9fefe6b8.iframe.bundle.js'},{'revision':null,'url':'61.a4df6f09.iframe.bundle.js'},{'revision':null,'url':'62.15502123.iframe.bundle.js'},{'revision':null,'url':'7.80075607.iframe.bundle.js'},{'revision':null,'url':'8.8e600852.iframe.bundle.js'},{'revision':null,'url':'9.4f39f828.iframe.bundle.js'},{'revision':'427bedddbcf73cdddc0714d670551d8a','url':'iframe.html'},{'revision':null,'url':'main.5d0e88c1.iframe.bundle.js'},{'revision':null,'url':'polyfills-dom.480b008b.iframe.bundle.js'},{'revision':null,'url':'runtime~main.8099823e.iframe.bundle.js'},{'revision':null,'url':'static/css/main.529930b7.chunk.css'},{'revision':null,'url':'static/css/vendors~main.7bc06244.chunk.css'},{'revision':null,'url':'vendors~main.508e02d7.iframe.bundle.js'},{'revision':null,'url':'vendors~polyfills-core-js.6c20b9cb.iframe.bundle.js'}]);var fileExtensionRegexp=new RegExp("/[^/?]+\\.[^/]+$");registerRoute((function(_ref){var request=_ref.request,url=_ref.url;return"navigate"===request.mode&&(!url.pathname.startsWith("/_")&&!url.pathname.match(fileExtensionRegexp))}),function createHandlerBoundToURL(url){return getOrCreatePrecacheController().createHandlerBoundToURL(url)}("./index.html")),registerRoute((function(_ref2){var url=_ref2.url;return url.origin===self.location.origin&&url.pathname.endsWith(".png")}),new class StaleWhileRevalidate_StaleWhileRevalidate extends Strategy_Strategy{constructor(options){super(options),this.plugins.some((p=>"cacheWillUpdate"in p))||this.plugins.unshift(cacheOkAndOpaquePlugin)}async _handle(request,handler){const fetchAndCachePromise=handler.fetchAndCachePut(request).catch((()=>{}));let error,response=await handler.cacheMatch(request);if(response)0;else{0;try{response=await fetchAndCachePromise}catch(err){error=err}}if(!response)throw new WorkboxError_WorkboxError("no-response",{url:request.url,error:error});return response}}({cacheName:"images",plugins:[new class ExpirationPlugin_ExpirationPlugin{constructor(config={}){this.cachedResponseWillBeUsed=async({event:event,request:request,cacheName:cacheName,cachedResponse:cachedResponse})=>{if(!cachedResponse)return null;const isFresh=this._isResponseDateFresh(cachedResponse),cacheExpiration=this._getCacheExpiration(cacheName);dontWaitFor(cacheExpiration.expireEntries());const updateTimestampDone=cacheExpiration.updateTimestamp(request.url);if(event)try{event.waitUntil(updateTimestampDone)}catch(error){0}return isFresh?cachedResponse:null},this.cacheDidUpdate=async({cacheName:cacheName,request:request})=>{const cacheExpiration=this._getCacheExpiration(cacheName);await cacheExpiration.updateTimestamp(request.url),await cacheExpiration.expireEntries()},this._config=config,this._maxAgeSeconds=config.maxAgeSeconds,this._cacheExpirations=new Map,config.purgeOnQuotaError&&function registerQuotaErrorCallback(callback){quotaErrorCallbacks.add(callback)}((()=>this.deleteCacheAndMetadata()))}_getCacheExpiration(cacheName){if(cacheName===cacheNames_getRuntimeName())throw new WorkboxError_WorkboxError("expire-custom-caches-only");let cacheExpiration=this._cacheExpirations.get(cacheName);return cacheExpiration||(cacheExpiration=new CacheExpiration_CacheExpiration(cacheName,this._config),this._cacheExpirations.set(cacheName,cacheExpiration)),cacheExpiration}_isResponseDateFresh(cachedResponse){if(!this._maxAgeSeconds)return!0;const dateHeaderTimestamp=this._getDateHeaderTimestamp(cachedResponse);if(null===dateHeaderTimestamp)return!0;return dateHeaderTimestamp>=Date.now()-1e3*this._maxAgeSeconds}_getDateHeaderTimestamp(cachedResponse){if(!cachedResponse.headers.has("date"))return null;const dateHeader=cachedResponse.headers.get("date"),headerTime=new Date(dateHeader).getTime();return isNaN(headerTime)?null:headerTime}async deleteCacheAndMetadata(){for(const[cacheName,cacheExpiration]of this._cacheExpirations)await self.caches.delete(cacheName),await cacheExpiration.delete();this._cacheExpirations=new Map}}({maxEntries:50})]})),self.addEventListener("message",(function(event){event.data&&"SKIP_WAITING"===event.data.type&&self.skipWaiting()}))}]);